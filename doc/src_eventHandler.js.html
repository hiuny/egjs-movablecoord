<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Source: src/eventHandler.js | egjs::movableCoord - API</title>
    
    <meta name="description" content="A module used to change the information of user action entered by various input devices such as touch screen or mouse into logical coordinates within the virtual coordinate system. The coordinate information sorted by time events occurred is provided if animations are made by user actions. You can implement a user interface by applying the logical coordinates provided. " />
    
        <meta name="keywords" content="jQuery, UI Component, egjs, movableCoord" />
        <meta name="keyword" content="jQuery, UI Component, egjs, movableCoord" />
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <link rel="canonical" href="http://naver.github.io/egjs/latest/doc/"/>
    
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":true,"cleverLinks":true,"default":{"outputSourceFiles":true},"applicationName":"egjs","disqus":"egjs","googleAnalytics":"","openGraph":{"title":"","type":"website","image":"","site_name":"","url":""},"meta":{"title":"egjs::movableCoord - API","description":"A module used to change the information of user action entered by various input devices such as touch screen or mouse into logical coordinates within the virtual coordinate system. The coordinate information sorted by time events occurred is provided if animations are made by user actions. You can implement a user interface by applying the logical coordinates provided. ","keyword":"jQuery, UI Component, egjs, movableCoord"},"linenums":true,"link":{"canonical":"http://naver.github.io/egjs/latest/doc/"}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="http://naver.github.io/egjs/">egjs</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
        <!-- Non Grouping Version -->
        
            

        
            

<li class="item" data-name="eg.MovableCoord">
    <span class="title">
        <a href="eg.MovableCoord.html">eg.MovableCoord</a>
        
    </span>
    <ul class="members itemMembers expends">
    
    <span class="subtitle">Members</span>
    
        <li data-name="eg.MovableCoord.DIRECTION_ALL"><a href="eg.MovableCoord.html#.DIRECTION_ALL">DIRECTION_ALL</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_DOWN"><a href="eg.MovableCoord.html#.DIRECTION_DOWN">DIRECTION_DOWN</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_HORIZONTAL"><a href="eg.MovableCoord.html#.DIRECTION_HORIZONTAL">DIRECTION_HORIZONTAL</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_LEFT"><a href="eg.MovableCoord.html#.DIRECTION_LEFT">DIRECTION_LEFT</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_NONE"><a href="eg.MovableCoord.html#.DIRECTION_NONE">DIRECTION_NONE</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_RIGHT"><a href="eg.MovableCoord.html#.DIRECTION_RIGHT">DIRECTION_RIGHT</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_UP"><a href="eg.MovableCoord.html#.DIRECTION_UP">DIRECTION_UP</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_VERTICAL"><a href="eg.MovableCoord.html#.DIRECTION_VERTICAL">DIRECTION_VERTICAL</a></li>
    
    </ul>
    <ul class="typedefs itemMembers expends">
    
    </ul>
    <ul class="methods itemMembers expends">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="eg.MovableCoord#bind"><a href="eg.MovableCoord.html#bind">bind</a></li>
    
        <li data-name="eg.MovableCoord#destroy"><a href="eg.MovableCoord.html#destroy">destroy</a></li>
    
        <li data-name="eg.MovableCoord#disableInput"><a href="eg.MovableCoord.html#disableInput">disableInput</a></li>
    
        <li data-name="eg.MovableCoord#enableInput"><a href="eg.MovableCoord.html#enableInput">enableInput</a></li>
    
        <li data-name="eg.MovableCoord#get"><a href="eg.MovableCoord.html#get">get</a></li>
    
        <li data-name="eg.MovableCoord#getHammer"><a href="eg.MovableCoord.html#getHammer">getHammer</a></li>
    
        <li data-name="eg.MovableCoord#hasOn"><a href="eg.MovableCoord.html#hasOn">hasOn</a> <img src="img/i.png" width="14" title="inherited" alt="inherited"></li>
    
        <li data-name="eg.MovableCoord#off"><a href="eg.MovableCoord.html#off">off</a> <img src="img/i.png" width="14" title="inherited" alt="inherited"></li>
    
        <li data-name="eg.MovableCoord#on"><a href="eg.MovableCoord.html#on">on</a> <img src="img/i.png" width="14" title="inherited" alt="inherited"></li>
    
        <li data-name="eg.MovableCoord#once"><a href="eg.MovableCoord.html#once">once</a> <img src="img/i.png" width="14" title="inherited" alt="inherited"></li>
    
        <li data-name="eg.MovableCoord#option"><a href="eg.MovableCoord.html#option">option</a> <img src="img/i.png" width="14" title="inherited" alt="inherited"></li>
    
        <li data-name="eg.MovableCoord#setBy"><a href="eg.MovableCoord.html#setBy">setBy</a></li>
    
        <li data-name="eg.MovableCoord#setTo"><a href="eg.MovableCoord.html#setTo">setTo</a></li>
    
        <li data-name="eg.MovableCoord#trigger"><a href="eg.MovableCoord.html#trigger">trigger</a> <img src="img/i.png" width="14" title="inherited" alt="inherited"></li>
    
        <li data-name="eg.MovableCoord#unbind"><a href="eg.MovableCoord.html#unbind">unbind</a></li>
    
    </ul>
    <ul class="events itemMembers expends">
    
    <span class="subtitle">Events</span>
    
        <li data-name="eg.MovableCoord#event:animationEnd"><a href="eg.MovableCoord.html#event:animationEnd">animationEnd</a></li>
    
        <li data-name="eg.MovableCoord#event:change"><a href="eg.MovableCoord.html#event:change">change</a></li>
    
        <li data-name="eg.MovableCoord#event:hold"><a href="eg.MovableCoord.html#event:hold">hold</a></li>
    
        <li data-name="eg.MovableCoord#event:release"><a href="eg.MovableCoord.html#event:release">release</a></li>
    
    </ul>

    
    <span class="title" style="margin-top:10px"><a href="index.html">readme</a></span>

</li>

        
    
    </ul>
</div>

    <div class="main">
        <h1 class="page-title" data-filename="src_eventHandler.js.html">Source: src/eventHandler.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Coordinate from "./Coordinate";
import {DIRECTION} from "./consts";

export default superclass => class extends superclass {
	constructor() {
		super();
		this._status = {
			grabOutside: false,		// check whether user's action started on outside
			currentHammer: null,		// current hammer instance
			currentOptions: {},		// current bind options
			moveDistance: null,		// a position of the first user's action
			prevented: false,		//  check whether the animation event was prevented
		};
	}

	_setCurrentTarget(hammer, options) {
		this._status.currentOptions = options;
		this._status.currentHanmmer = hammer;
	}

	// panstart event handler
	_start(e) {
		if (!this._status.currentOptions.interruptable &amp;&amp; this._status.prevented) {
			return;
		}
		const pos = this.get();
		const min = this.options.min;
		const max = this.options.max;

		this._setInterrupt(true);
		this._grab(min, max, this.options.circular);
		/**
		 * This event is fired when a user holds an element on the screen of the device.
		 * @ko 사용자가 기기의 화면에 손을 대고 있을 때 발생하는 이벤트
		 * @event eg.MovableCoord#hold
		 * @param {Object} param The object of data to be sent when the event is fired&lt;ko>이벤트가 발생할 때 전달되는 데이터 객체&lt;/ko>
		 * @param {Array} param.pos coordinate &lt;ko>좌표 정보&lt;/ko>
		 * @param {Number} param.pos.0 The X coordinate&lt;ko>x 좌표&lt;/ko>
		 * @param {Number} param.pos.1 The Y coordinate&lt;ko>y 좌표&lt;/ko>
		 * @param {Object} param.hammerEvent The event information of Hammer.JS. It returns null if the event is fired through a call to the setTo() or setBy() method.&lt;ko>Hammer.JS의 이벤트 정보. setTo() 메서드나 setBy() 메서드를 호출해 이벤트가 발생했을 때는 'null'을 반환한다.&lt;/ko>
		 *
		 */
		this.trigger("hold", {
			pos: pos.concat(),
			hammerEvent: e,
		});

		this._status.moveDistance = pos.concat();
		this._status.grabOutside = Coordinate.isOutside(pos, min, max);
	}

	// panmove event handler
	_move(e) {
		if (!this._isInterrupting() || !this._status.moveDistance) {
			return;
		}
		let pos = this.get(true);
		const min = this.options.min;
		const max = this.options.max;
		const bounce = this.options.bounce;
		const margin = this.options.margin;
		const currentOptions = this._status.currentOptions;
		const direction = currentOptions.direction;
		const scale = currentOptions.scale;
		const userDirection = Coordinate.getDirectionByAngle(
			e.angle, currentOptions.thresholdAngle);
		const out = [
			margin[0] + bounce[0],
			margin[1] + bounce[1],
			margin[2] + bounce[2],
			margin[3] + bounce[3],
		];
		let prevent = false;

		// not support offset properties in Hammerjs - start
		const prevInput = this._status.currentHanmmer.session.prevInput;

		/* eslint-disable no-param-reassign */
		if (prevInput) {
			e.offsetX = e.deltaX - prevInput.deltaX;
			e.offsetY = e.deltaY - prevInput.deltaY;
		} else {
			e.offsetX = 0;
			e.offsetY = 0;
		}

		// not support offset properties in Hammerjs - end
		if (Coordinate.isHorizontal(direction, userDirection)) {
			this._status.moveDistance[0] += (e.offsetX * scale[0]);
			prevent = true;
		}
		if (Coordinate.isVertical(direction, userDirection)) {
			this._status.moveDistance[1] += (e.offsetY * scale[1]);
			prevent = true;
		}
		if (prevent) {
			e.srcEvent.preventDefault();
			e.srcEvent.stopPropagation();
		}
		e.preventSystemEvent = prevent;
		/* eslint-enable no-param-reassign */

		pos[0] = this._status.moveDistance[0];
		pos[1] = this._status.moveDistance[1];
		pos = Coordinate.getCircularPos(pos, min, max, this.options.circular);

		// from outside to inside
		if (this._status.grabOutside &amp;&amp; !Coordinate.isOutside(pos, min, max)) {
			this._status.grabOutside = false;
		}

		// when move pointer is held in outside
		let tv;
		let tn;
		let tx;

		if (this._status.grabOutside) {
			tn = min[0] - out[3];
			tx = max[0] + out[1];
			tv = pos[0];
			/* eslint-disable no-nested-ternary */
			pos[0] = tv > tx ? tx : (tv &lt; tn ? tn : tv);
			tn = min[1] - out[0];
			tx = max[1] + out[2];
			tv = pos[1];
			pos[1] = tv > tx ? tx : (tv &lt; tn ? tn : tv);
			/* eslint-enable no-nested-ternary */
		} else {
			// when start pointer is held in inside
			// get a initialization slope value to prevent smooth animation.
			const initSlope = this._easing(0.00001) / 0.00001;

			if (pos[1] &lt; min[1]) { // up
				tv = (min[1] - pos[1]) / (out[0] * initSlope);
				pos[1] = min[1] - this._easing(tv) * out[0];
			} else if (pos[1] > max[1]) { // down
				tv = (pos[1] - max[1]) / (out[2] * initSlope);
				pos[1] = max[1] + this._easing(tv) * out[2];
			}
			if (pos[0] &lt; min[0]) { // left
				tv = (min[0] - pos[0]) / (out[3] * initSlope);
				pos[0] = min[0] - this._easing(tv) * out[3];
			} else if (pos[0] > max[0]) { // right
				tv = (pos[0] - max[0]) / (out[1] * initSlope);
				pos[0] = max[0] + this._easing(tv) * out[1];
			}
		}
		this._setPosAndTriggerChange(pos, true, e);
	}

	// panend event handler
	_end(e) {
		const pos = this.get();

		if (!this._isInterrupting() || !this._status.moveDistance) {
			return;
		}

		// Abort the animating post process when "tap" occurs
		if (e.distance === 0 /* e.type === "tap" */) {
			this._setInterrupt(false);
			this.trigger("release", {
				depaPos: pos.concat(),
				destPos: pos.concat(),
				hammerEvent: e || null,
			});
		} else {
			const direction = this._status.currentOptions.direction;
			const scale = this._status.currentOptions.scale;
			let vX = Math.abs(e.velocityX);
			let vY = Math.abs(e.velocityY);

			!(direction &amp; DIRECTION.DIRECTION_HORIZONTAL) &amp;&amp; (vX = 0);
			!(direction &amp; DIRECTION.DIRECTION_VERTICAL) &amp;&amp; (vY = 0);

			const offset = Coordinate.getNextOffsetPos([
				vX * (e.deltaX &lt; 0 ? -1 : 1) * scale[0],
				vY * (e.deltaY &lt; 0 ? -1 : 1) * scale[1],
			], this.options.deceleration);
			let destPos = [pos[0] + offset[0], pos[1] + offset[1]];

			destPos = Coordinate.getPointOfIntersection(pos, destPos,
				this.options.min, this.options.max,
				this.options.circular, this.options.bounce);
			/**
			 * This event is fired when a user release an element on the screen of the device.
			 * @ko 사용자가 기기의 화면에서 손을 뗐을 때 발생하는 이벤트
			 * @event eg.MovableCoord#release
			 *
			 * @param {Object} param The object of data to be sent when the event is fired&lt;ko>이벤트가 발생할 때 전달되는 데이터 객체&lt;/ko>
			 * @param {Array} param.depaPos The coordinates when releasing an element&lt;ko>손을 뗐을 때의 좌표현재 &lt;/ko>
			 * @param {Number} param.depaPos.0 The X coordinate &lt;ko> x 좌표&lt;/ko>
			 * @param {Number} param.depaPos.1 The Y coordinate &lt;ko> y 좌표&lt;/ko>
			 * @param {Array} param.destPos The coordinates to move to after releasing an element&lt;ko>손을 뗀 뒤에 이동할 좌표&lt;/ko>
			 * @param {Number} param.destPos.0 The X coordinate &lt;ko>x 좌표&lt;/ko>
			 * @param {Number} param.destPos.1 The Y coordinate &lt;ko>y 좌표&lt;/ko>
			 * @param {Object} param.hammerEvent The event information of Hammer.JS. It returns null if the event is fired through a call to the setTo() or setBy() method.&lt;ko>Hammer.JS의 이벤트 정보. setTo() 메서드나 setBy() 메서드를 호출해 이벤트가 발생했을 때는 'null'을 반환한다&lt;/ko>
			 *
			 */
			this.trigger("release", {
				depaPos: pos.concat(),
				destPos,
				hammerEvent: e || null,
			});
			if (pos[0] !== destPos[0] || pos[1] !== destPos[1]) {
				this._animateTo(destPos, null, e || null);
			} else {
				this._setInterrupt(false);
			}
		}
		this._status.moveDistance = null;
	}

	_isInterrupting() {
		// when interruptable is 'true', return value is always 'true'.
		return this._status.currentOptions.interruptable || this._status.prevented;
	}

	_setInterrupt(prevented) {
		!this._status.currentOptions.interruptable &amp;&amp;
		(this._status.prevented = prevented);
	}
};
</code></pre>
        </article>
    </section>






        
        <!-- disqus code -->
        <div id="disqus_thread"></div>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        <!-- // disqus code -->
        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sat Apr 22 2017 14:10:29 GMT+0900 (KST)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/main.js"></script>
</body>
</html>
